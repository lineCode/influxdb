// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: batch_cursor.gen.go.tmpl

package storage

import (
	"context"

	"github.com/influxdata/influxdb/tsdb"
)

// ********************
// Float BatchCursor

type floatMultiShardBatchCursor struct {
	tsdb.FloatBatchCursor
	ctx   context.Context
	itrs  tsdb.CursorIterators
	req   *tsdb.CursorRequest
	err   error
	limit uint64
	count uint64
}

func newFloatMultiShardBatchCursor(ctx context.Context, cur tsdb.FloatBatchCursor, rr *readRequest, req *tsdb.CursorRequest, itrs tsdb.CursorIterators) *floatMultiShardBatchCursor {
	return &floatMultiShardBatchCursor{
		FloatBatchCursor: cur,
		ctx:              ctx,
		req:              req,
		itrs:             itrs,
		limit:            rr.limit,
	}
}

func (c *floatMultiShardBatchCursor) Err() error { return c.err }

func (c *floatMultiShardBatchCursor) Next() (key []int64, value []float64) {
	for {
		ks, vs := c.FloatBatchCursor.Next()
		if len(ks) == 0 {
			if c.nextBatchCursor() {
				continue
			}
		}
		c.count += uint64(len(ks))
		if c.count > c.limit {
			diff := c.count - c.limit
			c.count -= diff
			rem := uint64(len(ks)) - diff
			ks = ks[:rem]
			vs = vs[:rem]
		}
		return ks, vs
	}
}

func (c *floatMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.itrs) == 0 {
		return false
	}

	c.FloatBatchCursor.Close()

RETRY:
	var itr tsdb.CursorIterator
	var cur tsdb.Cursor
	for cur == nil && len(c.itrs) > 0 {
		itr, c.itrs = c.itrs[0], c.itrs[1:]
		cur, _ = itr.Next(c.ctx, c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.FloatBatchCursor
		next, ok = cur.(tsdb.FloatBatchCursor)
		if !ok {
			cur.Close()
			goto RETRY
		}
		c.FloatBatchCursor = next
	} else {
		c.FloatBatchCursor = FloatEmptyBatchCursor
	}

	return ok
}

type floatEmptyBatchCursor struct{}

var FloatEmptyBatchCursor tsdb.FloatBatchCursor = &floatEmptyBatchCursor{}

func (*floatEmptyBatchCursor) Err() error                           { return nil }
func (*floatEmptyBatchCursor) Close()                               {}
func (*floatEmptyBatchCursor) Next() (key []int64, value []float64) { return nil, nil }

// ********************
// Integer BatchCursor

type integerMultiShardBatchCursor struct {
	tsdb.IntegerBatchCursor
	ctx   context.Context
	itrs  tsdb.CursorIterators
	req   *tsdb.CursorRequest
	err   error
	limit uint64
	count uint64
}

func newIntegerMultiShardBatchCursor(ctx context.Context, cur tsdb.IntegerBatchCursor, rr *readRequest, req *tsdb.CursorRequest, itrs tsdb.CursorIterators) *integerMultiShardBatchCursor {
	return &integerMultiShardBatchCursor{
		IntegerBatchCursor: cur,
		ctx:                ctx,
		req:                req,
		itrs:               itrs,
		limit:              rr.limit,
	}
}

func (c *integerMultiShardBatchCursor) Err() error { return c.err }

func (c *integerMultiShardBatchCursor) Next() (key []int64, value []int64) {
	for {
		ks, vs := c.IntegerBatchCursor.Next()
		if len(ks) == 0 {
			if c.nextBatchCursor() {
				continue
			}
		}
		c.count += uint64(len(ks))
		if c.count > c.limit {
			diff := c.count - c.limit
			c.count -= diff
			rem := uint64(len(ks)) - diff
			ks = ks[:rem]
			vs = vs[:rem]
		}
		return ks, vs
	}
}

func (c *integerMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.itrs) == 0 {
		return false
	}

	c.IntegerBatchCursor.Close()

RETRY:
	var itr tsdb.CursorIterator
	var cur tsdb.Cursor
	for cur == nil && len(c.itrs) > 0 {
		itr, c.itrs = c.itrs[0], c.itrs[1:]
		cur, _ = itr.Next(c.ctx, c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.IntegerBatchCursor
		next, ok = cur.(tsdb.IntegerBatchCursor)
		if !ok {
			cur.Close()
			goto RETRY
		}
		c.IntegerBatchCursor = next
	} else {
		c.IntegerBatchCursor = IntegerEmptyBatchCursor
	}

	return ok
}

type integerEmptyBatchCursor struct{}

var IntegerEmptyBatchCursor tsdb.IntegerBatchCursor = &integerEmptyBatchCursor{}

func (*integerEmptyBatchCursor) Err() error                         { return nil }
func (*integerEmptyBatchCursor) Close()                             {}
func (*integerEmptyBatchCursor) Next() (key []int64, value []int64) { return nil, nil }

// ********************
// Unsigned BatchCursor

type unsignedMultiShardBatchCursor struct {
	tsdb.UnsignedBatchCursor
	ctx   context.Context
	itrs  tsdb.CursorIterators
	req   *tsdb.CursorRequest
	err   error
	limit uint64
	count uint64
}

func newUnsignedMultiShardBatchCursor(ctx context.Context, cur tsdb.UnsignedBatchCursor, rr *readRequest, req *tsdb.CursorRequest, itrs tsdb.CursorIterators) *unsignedMultiShardBatchCursor {
	return &unsignedMultiShardBatchCursor{
		UnsignedBatchCursor: cur,
		ctx:                 ctx,
		req:                 req,
		itrs:                itrs,
		limit:               rr.limit,
	}
}

func (c *unsignedMultiShardBatchCursor) Err() error { return c.err }

func (c *unsignedMultiShardBatchCursor) Next() (key []int64, value []uint64) {
	for {
		ks, vs := c.UnsignedBatchCursor.Next()
		if len(ks) == 0 {
			if c.nextBatchCursor() {
				continue
			}
		}
		c.count += uint64(len(ks))
		if c.count > c.limit {
			diff := c.count - c.limit
			c.count -= diff
			rem := uint64(len(ks)) - diff
			ks = ks[:rem]
			vs = vs[:rem]
		}
		return ks, vs
	}
}

func (c *unsignedMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.itrs) == 0 {
		return false
	}

	c.UnsignedBatchCursor.Close()

RETRY:
	var itr tsdb.CursorIterator
	var cur tsdb.Cursor
	for cur == nil && len(c.itrs) > 0 {
		itr, c.itrs = c.itrs[0], c.itrs[1:]
		cur, _ = itr.Next(c.ctx, c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.UnsignedBatchCursor
		next, ok = cur.(tsdb.UnsignedBatchCursor)
		if !ok {
			cur.Close()
			goto RETRY
		}
		c.UnsignedBatchCursor = next
	} else {
		c.UnsignedBatchCursor = UnsignedEmptyBatchCursor
	}

	return ok
}

type unsignedEmptyBatchCursor struct{}

var UnsignedEmptyBatchCursor tsdb.UnsignedBatchCursor = &unsignedEmptyBatchCursor{}

func (*unsignedEmptyBatchCursor) Err() error                          { return nil }
func (*unsignedEmptyBatchCursor) Close()                              {}
func (*unsignedEmptyBatchCursor) Next() (key []int64, value []uint64) { return nil, nil }

// ********************
// String BatchCursor

type stringMultiShardBatchCursor struct {
	tsdb.StringBatchCursor
	ctx   context.Context
	itrs  tsdb.CursorIterators
	req   *tsdb.CursorRequest
	err   error
	limit uint64
	count uint64
}

func newStringMultiShardBatchCursor(ctx context.Context, cur tsdb.StringBatchCursor, rr *readRequest, req *tsdb.CursorRequest, itrs tsdb.CursorIterators) *stringMultiShardBatchCursor {
	return &stringMultiShardBatchCursor{
		StringBatchCursor: cur,
		ctx:               ctx,
		req:               req,
		itrs:              itrs,
		limit:             rr.limit,
	}
}

func (c *stringMultiShardBatchCursor) Err() error { return c.err }

func (c *stringMultiShardBatchCursor) Next() (key []int64, value []string) {
	for {
		ks, vs := c.StringBatchCursor.Next()
		if len(ks) == 0 {
			if c.nextBatchCursor() {
				continue
			}
		}
		c.count += uint64(len(ks))
		if c.count > c.limit {
			diff := c.count - c.limit
			c.count -= diff
			rem := uint64(len(ks)) - diff
			ks = ks[:rem]
			vs = vs[:rem]
		}
		return ks, vs
	}
}

func (c *stringMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.itrs) == 0 {
		return false
	}

	c.StringBatchCursor.Close()

RETRY:
	var itr tsdb.CursorIterator
	var cur tsdb.Cursor
	for cur == nil && len(c.itrs) > 0 {
		itr, c.itrs = c.itrs[0], c.itrs[1:]
		cur, _ = itr.Next(c.ctx, c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.StringBatchCursor
		next, ok = cur.(tsdb.StringBatchCursor)
		if !ok {
			cur.Close()
			goto RETRY
		}
		c.StringBatchCursor = next
	} else {
		c.StringBatchCursor = StringEmptyBatchCursor
	}

	return ok
}

type stringEmptyBatchCursor struct{}

var StringEmptyBatchCursor tsdb.StringBatchCursor = &stringEmptyBatchCursor{}

func (*stringEmptyBatchCursor) Err() error                          { return nil }
func (*stringEmptyBatchCursor) Close()                              {}
func (*stringEmptyBatchCursor) Next() (key []int64, value []string) { return nil, nil }

// ********************
// Boolean BatchCursor

type booleanMultiShardBatchCursor struct {
	tsdb.BooleanBatchCursor
	ctx   context.Context
	itrs  tsdb.CursorIterators
	req   *tsdb.CursorRequest
	err   error
	limit uint64
	count uint64
}

func newBooleanMultiShardBatchCursor(ctx context.Context, cur tsdb.BooleanBatchCursor, rr *readRequest, req *tsdb.CursorRequest, itrs tsdb.CursorIterators) *booleanMultiShardBatchCursor {
	return &booleanMultiShardBatchCursor{
		BooleanBatchCursor: cur,
		ctx:                ctx,
		req:                req,
		itrs:               itrs,
		limit:              rr.limit,
	}
}

func (c *booleanMultiShardBatchCursor) Err() error { return c.err }

func (c *booleanMultiShardBatchCursor) Next() (key []int64, value []bool) {
	for {
		ks, vs := c.BooleanBatchCursor.Next()
		if len(ks) == 0 {
			if c.nextBatchCursor() {
				continue
			}
		}
		c.count += uint64(len(ks))
		if c.count > c.limit {
			diff := c.count - c.limit
			c.count -= diff
			rem := uint64(len(ks)) - diff
			ks = ks[:rem]
			vs = vs[:rem]
		}
		return ks, vs
	}
}

func (c *booleanMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.itrs) == 0 {
		return false
	}

	c.BooleanBatchCursor.Close()

RETRY:
	var itr tsdb.CursorIterator
	var cur tsdb.Cursor
	for cur == nil && len(c.itrs) > 0 {
		itr, c.itrs = c.itrs[0], c.itrs[1:]
		cur, _ = itr.Next(c.ctx, c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.BooleanBatchCursor
		next, ok = cur.(tsdb.BooleanBatchCursor)
		if !ok {
			cur.Close()
			goto RETRY
		}
		c.BooleanBatchCursor = next
	} else {
		c.BooleanBatchCursor = BooleanEmptyBatchCursor
	}

	return ok
}

type booleanEmptyBatchCursor struct{}

var BooleanEmptyBatchCursor tsdb.BooleanBatchCursor = &booleanEmptyBatchCursor{}

func (*booleanEmptyBatchCursor) Err() error                        { return nil }
func (*booleanEmptyBatchCursor) Close()                            {}
func (*booleanEmptyBatchCursor) Next() (key []int64, value []bool) { return nil, nil }
